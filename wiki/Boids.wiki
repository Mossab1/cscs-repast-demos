#summary Boids Java implementation by Rowan Copley
#sidebar TableOfContents

_Wiki note: this will become two separate tutorials for the two implementations, with only code changed for each. For now this will be only the Java tutorial._

= 0. Before Beginning = 
Before we can do anything with Repast Simphony, we need to make sure that we have a proper installation of Repast Simphony 2.0. Instructions on downloading and installing Repast Simphony on various platforms can be found on the Repast website.

This tutorial will assume a familiarity with Java. The structure will be as follows: an introduction to the model; getting a framework for the model written in Java; adding the three main rules as functions; synthesizing the outputs of each rule in a useful way, and finally ideas for further extending the model.

= 1. What is Boids? =
Boids is an agent-based model which simulates the steering behavior of flocking birds using simple to understand rules. Applications of the model range from studying Artificial Life to implementing the algorithm in a flock of robots. The advantage of Boids is the bottom-up approach to flocking, rather than the top-down approach: each individual Boid need only follow a few simple rules and flocks will emerge naturally.
The overall design of the Boids algorithm is based on [http://www.red3d.com/cwr/boids/ Craig Reynold's original Boids] algorithm consists of three rules:
  * Alignment: Each Boid steers itself to align its heading with that of its neighbors
  * Cohesion: Each Boid steers itself to the average position of its flockmates
  * Separation: Each Boid steers itself in order not to crowd its neighbors

These three rules can conflict with each other, as we will see, the way that we deal with those conflicts will influence the final behavior of the flocks of Boids.

Boids is a study of the kind of algorithm that starlings might follow in order to create these spectacular clouds of birds:
<wiki:video url="http://www.youtube.com/watch?v=eakKfY5aHmY"/>

= 2. Setting up the framework =

Open Repast and switch to the Java perspective by clicking the Java button in the upper. Next, we need to create a new Java project for Repast. To do this properly, click File, go to New, and click Other. Find Repast Simphony Project in the Wizard selection box and click it, then click Next. Nname your project Boids and click Finish. 

We now have a new Repast Java project. The only files we're going to create for now are in the /src subfolder, so the rest of the project files can safely be ignored. Click on the arrow to the left of the /src subfolder. A subfolder with your project's name will drop down underneath /src. The two files inside of this subfolder can safely be deleted. In their place we can make a new Java file called Boid. To do this, right-click on the folder called Boids inside /src and click New, then click Class. Name it Boid and click Finish. 

Your project's hierarchy should look like Fig. xxx. Next, add in code to your Boid class so it looks like this:

{{{
package Boids;

public class Boid {
   double distance;
   double heading;
   public Boid(){
      distance = 0.3;
      heading = randomRadian();
   }
	
   @ScheduledMethod(start = 1, interval = 1)
   public void step(){
		
   }
}
}}}

The method named Boid will be a constructor that we'll return to when we create the Context Builder for Boids. The step() method is a method that will be called at every tick, or time step, of the simulation. This is delineated by line xxx of the code above. 

You'll notice that the @ScheduledMethod command is underlined in red. This is because we haven't made the necessary import for the command. There are two ways of doing this; either hover over the command until a popup window appears and click on "Import ScheduledMethod." The second way is to click on Source in the top menu and click on Organize Imports. As we add more code, you should automatically check for an import any time a command is underlined in red.

== step() and forward() methods ==

Here is the code we'll use for now for step():

{{{
public void step(){
   forward();
}
}}}

Now create the forward method below step():

{{{
public void forward(){
	NdPoint pt = space.getLocation(this);
	double moveX = pt.getX() + Math.cos(heading)*distance;
	double moveY = pt.getY() + Math.sin(heading)*distance;
	space.moveTo(this, moveX, moveY);
	grid.moveTo(this, (int)moveX, (int)moveY);
}
}}}

In order to understand this block of code, you must first understand the underlying representations of space that Repast uses. In this particular model, we use both kinds: we use a grid, where each object has a location on a grid of discrete cells defined by two integers; and we use a continuous space, where each object has a location defined by two doubles. If we were making a three-dimensional model, we would have three integers and three doubles for the grid and the continuous space, respectively. Both the grid representation of space and the continuous space representation of space are called projections. We will see later why we use both projections.

Whenever an object moves itself and we are using these two projections, we need to update both in order for them to make sense. This means that we will need to convert between one projection's co-ordinates and another's. So the first line of code in the method creates an object of type NdPoint which contains a representation of the Boid's current co-ordinates in the continuous space. The second and third lines in the method take the Boid's current co-ordinates and change them so that the Boid has moved by a total of 0.3, the value in distance, in the direction of the variable heading.

== Context Builder ==

Create a new class in the Boids package and name it BoidsContextBuilder. Let's do the simple stuff first:

{{{
public Context build(Context<Object> context) {
   context.setId("Boids");
   int width = 16;
   int height = 16;
   int numBoids = 20;
		
   //placeholder

   return context;
}
}}}

Next, we need to create the two space projections, our grid and our continuous space. This will go where our placeholder comment is right now. Here is the code:

{{{
ContinuousSpaceFactory spaceFactory = ContinuousSpaceFactoryFinder.createContinuousSpaceFactory(null);
ContinuousSpace<Object> space = spaceFactory.createContinuousSpace
("space",context,new RandomCartesianAdder<Object>(), new 
repast.simphony.space.continuous.WrapAroundBorders(), width,height);
		
Grid<Object> grid = GridFactoryFinder.createGridFactory(null).createGrid("Grid", 
context, new GridBuilderParameters<Object>(new WrapAroundBorders(), new
 SimpleGridAdder<Object>(),true, width,height));
}}}

And lastly, we need to create the Boids and add them to the context. We do that with this code snippet, which goes right underneath the last snippet of code:

{{{
for(int i = 0; i < numBoids; i++){
   Boid boid = new Boid(space, grid);
   context.add(boid);
   NdPoint pt = space.getLocation(boid);
   grid.moveTo(boid, (int)pt.getX(), (int)pt.getY());
}
}}}

Lastly, we modify the Boid constructor.

== Boid() ==

This is how the constructor in the Boid class should look:

{{{
public Boid(ContinuousSpace<Object> space, Grid<Object> grid){
   this.space = space;
   this.grid = grid;
   heading = randomRadian();
}
}}}

== Set up a display ==

Click on the arrow to the right of the green play button to see the popup menu of all the run options for your models. Find "Boids Model" and click it. In a minute, a Java window will appear.

...

Your model should now run! Click on the blue power button, and then click on either the blue next button or the blue play button to step the simulation forward by one step or many steps, respectively. 

= 3. Alignment =

The goal here is to average the heading of all Boids within a certain distance that we'll call it neighborhoodRadius. This average is the new heading of any given Boid at their next timestep.

== neighborhood() method ==

== alignmentDirection() method ==
We will be changing this method later when we add random weights.

= 4. Cohesion =

In order for a group of birds to be labeled a flock, or a group of fish to be labeled a school, they need to have a certain proximity to each other. The direction that the Boid should turn in order to get closer to its neighboring Boids is returned by the method cohesionDirection().


== cohesionDirection() method ==
We will be changing this method later when we add random weights.

In order to fly close to their flockmates, each Boid takes all its neighboring Boids (again, defined as all the Boids which are closer than the distance defined by neighborhood radius) and determines the average direction of them from itself. (So if there were two Boids in the neighborhood set of a particular Boid, and they were North and West or 0 and 270 degrees respectively, then the average direction of the Boids would be Northwest or 315 degrees.) If the neighboring Boids are, on average, too far away from this particular Boid, then it shifts its course to face the average direction of its neighboring Boids. 

= 5. Separation =
Real flocks have another key trait: the units comprising them are fairly evenly spaced, and no one unit is crowded out. 

== separationDirection() method ==
We will be changing this method later when we add random weights.

This can be accomplished very similarly to the Cohesion method above -- a set of the neighboring Boids is made. However, all Boids which are not too close (not within the desiredDistance) can be ignored. The other difference is that the Boid must turn away from, not towards, the other Boids -- but turning the complete opposite direction is too far. Thus, we can introduce a turnSpeed which determines how much the Boid is to turn away from the other Boids. 

== toMyLeft() method ==

= 6. Putting it all together =

We now combine the three steering methods we established above into the single method, step().

== Adding random weights ==

To make this model look more lifelike, we can add random weighting to the three steering methods as well as the methods which allow the Boid to move sideways (moveTowards() and moveAwayFrom()).

= 7. Extending the model =

(0) http://www.red3d.com/cwr/boids/