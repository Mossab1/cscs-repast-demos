#summary The Bug Catcher Model
#sidebar TableOfContents

=*Summary*=

  * Model        : BugCatcher
  * Source Code  : https://cscs-repast-demos.googlecode.com/svn/mudit/BugCatcher/
  * Platform     : [RepastSReLogo RepastS ReLogo]
  * Mentor       : Dr. Eric Tatara
  * Author       : [Mudit Mudit Raj Gupta]

https://cscs-repast-demos.googlecode.com/svn/wiki/Images_Mudit/Bug(Index).JPG

------

=*Content*=

<wiki:toc max_depth="2" />

------

=1. Before Getting Started=

Before trying to use the model, make sure that Repast Simphony is installed properly (version 2.0 Beta, released on 12/3/2010 or later) is available to use.

Instructions on downloading and installing Repast Simphony on various platforms can be found on the [http://repast.sourceforge.net/download.html Repast download website].

RepastS models can be created with [http://repast.sourceforge.net/docs/RepastFlowGettingStarted.pdf Flowcharts], a Logo-like language called [http://repast.sourceforge.net/docs/ReLogoGettingStarted.pdf ReLogo], or purely in [http://repast.sourceforge.net/docs/RepastJavaGettingStarted.pdf Java and/or Groovy], and even C++ with [http://repast.sourceforge.net/docs/RepastHPCManual.pdf Repast HPC].

ReLogo was used to create the model. The documentations and other demo models on the same platform can be found [http://code.google.com/p/cscs-repast-demos/wiki/RepastSReLogo here].

It is suggested that you go through the following models also, as the guiding algorithm is quite similar, although the implementation is entirely different.

 # [Moth_Basic]
 # [Moth_Advance]


-----

= 2. Introduction=

A fly-killing device is used for pest control. A fly-killing device typically attracts flying insects, for example houseflies, wasps, moths and mosquitoes. The insects are killed or released. We have modeled such a device which kills the bugs after a user specified time. It is based on Bug Zapper. 

A bug zapper is a device that attracts and kills insects that are attracted by light. A light source attracts insects to an electrical grid, where they are electrocuted by touching two wires with a high voltage between them. The name stems from the characteristic zap sound produced when an insect is electrocuted.

A similar system is modeled here. Read the Description section to figure out the difference between the Moth_Advance model and BugCatcher Model. 

-----

=Description=

==Why is it different?==

The Bug Catcher model looks quite similar to the Moth_Advance model. In Moth_Advance model the intensity of the light source and the size of the light source are both adjustable, while when BugCatcher was modeled, it was assumed that the machine can catch bugs only in it's Moore's Neighborhood and this is fixed for all bug catching machines. The BugCatcher model can be made from the Moth_Advance model, but the way in which the two models are approached are different.

==Algorithm and implementation==

In the BugCatcher model, bugs move around randomly in an area and the bug catching machines are at various positions. The bugs get attracted towards (the center) the bug catching machines and get caught in them. They are electrocuted after and they die after some time. 

The population of the bugs and the number of bug catching machines are both adjustable by the user through the User Panel. The time between electrocution and death can also be changed by the user through the User Panel. The bug speed can also be controlled by the same.  

The basic model has two turtles. 

 # Bug
 # Machines 

*Note:* The complete source code of the model can be found [https://cscs-repast-demos.googlecode.com/svn/mudit/BugCatcher/ here]. This page does not explains the whole code. The available code is commented to be understood by the reader. This page explains certain code segments (from the source code) and explain the basic concept and design. 

Let us first start by talking about [http://code.google.com/p/cscs-repast-demos/source/browse/mudit/BugCatcher/src/bugcatcher/relogo/Bug.groovy moth.groovy]. This defines the characteristics of a bug. Taking the first block in the code. 

{{{

        def step()
	{
		//bug gets attracted towards the machine 
		def dir = maxOneOf(neighbors()){
					
		count(machinesOn(it))}
		face(dir)
		
		//Bug Speed can be adjusted by the user						
		fd(bugSpeed*0.5)

}}}

In the step() function defined in bug.groovy the bug faces a machine if there is one around. Once the bug is facing the machine it moves forward a distance, half of the value entered by the user. The bug checks weather the machine is in it's Moore's neighborhood. The task has been accompalished by the help of [file:///C:/RepastSimphony-2.0-beta/docs/ReLogoDocs/repast/simphony/relogo/Turtle.html#maxOneOf%28List,%20Closure%29 maxOneOf()], [file:///C:/RepastSimphony-2.0-beta/docs/ReLogoDocs/repast/simphony/relogo/Turtle.html#turtlesOn%28repast.simphony.relogo.Turtle%29 machinesOn()] and [count()]. Another very common function used here to face the required direction is [file:///C:/RepastSimphony-2.0-beta/docs/ReLogoDocs/repast/simphony/relogo/Turtle.html#face%28repast.simphony.relogo.Turtle%29 face()].



==User Panel==

https://cscs-repast-demos.googlecode.com/svn/wiki/Images_Mudit/Bug(Usr).JPG

==Data Sets, Outputters and External Plugin==

_to be added soon_

==Plots==

_to be added soon_

----

=4. Applications=


_to be added soon_
----

=5. Extending the Model=


_to be added soon_

----

=6. References=

 1. http://en.wikipedia.org/wiki/Bug_zapper

 2. http://home.howstuffworks.com/bug-zapper.htm

 3. http://en.wikipedia.org/wiki/Fly-killing_device