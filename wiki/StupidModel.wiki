#summary StupidModel Demo project.
#sidebar TableOfContents

=Summary=
 * Source Code  : https://cscs-repast-demos.googlecode.com/svn/richard/StupidModel/trunk/
 * Platform     : [RepastSJava Repast Simphony Java]
 * Mentor       : Dr. Eric Tatara
 * Author       : [Richard Richard Oliver Legendi]

<g:plusone size="medium"></g:plusone>

=Contents=
<wiki:toc max_depth="2" />

-----

= Introduction =
This tutorial is based on the article _[http://condor.depaul.edu/slytinen/abm/StupidModelFormulation.pdf StupidModel and Extensions: A template and teaching tool for agent-based modeling platforms]_ by Steven F. Railsback, Steven L. Lytinen and Stephen K. Jackson, and guides through a creation of a very simple model with random moving agents to a basic model with different agents interacting with each other and their surroundings in [http://repast.sourceforge.net/ Repast Simphony].

When we are finished, the running model should look like the following figure:

https://cscs-repast-demos.googlecode.com/svn/wiki/StupidModel/simulation.png

== Why the !StupidModel? ==
I am sure the !StupidModel considered a relevant learning /comparison tool for agent-based modelling. Several reference implementations may be found on [http://condor.depaul.edu/slytinen/abm/ Steven L. Lytinen's site]. Additional resources may be found at the [http://www.swarm.org/wiki/Software_templates SwarmWiki].

== Prerequisites ==
Before we start, make sure a proper installation of Repast Simphony (version 2.0 Beta, released on 12/3/2010 or later) is available to use.

Instructions on downloading and installing Repast Simphony on various platforms can be found on the [http://repast.sourceforge.net/download.html Repast download website].

Repast S can be used several ways: models may be created with [http://repast.sourceforge.net/docs/RepastFlowGettingStarted.pdf Flowcharts], a Logo-like language called [http://repast.sourceforge.net/docs/ReLogoGettingStarted.pdf ReLogo], or purely in [http://repast.sourceforge.net/docs/RepastJavaGettingStarted.pdf Java and/or Groovy], and even C++ with [http://repast.sourceforge.net/docs/RepastHPCManual.pdf Repast HPC].

In the current tutorial, we use Java to create the !StupidModel implementation with the help of the [http://repast.sourceforge.net/docs/api/repastjava/index.html Java API] offered by Repast Simphony. Following the tutorial does not require to read any of the referenced documents, however, they may be useful in the future.

= Notes on the Implementation =
The source code we use as example below in this document are formatted to be clear and as straightforward as possible. In the attached source code however, it is carefully written with several blocks of boilerplate code that is irrelevant from the view of the model (e.g., checking parameters of a function and making assertions about the state of the program). For clarity, these segments are omitted here, but may be found in the attached source code.

Although domain-specific languages like ReLogo shown to have many advantages in ABM when creating usual models like the !StupidModel `[3]`, this model itself is written purely in Java to illustrate the usage of the standard Repast Simphony Java API.

== Additional Resources ==
We have created extensive documentation for the final !StupidModel implementation, these may be found in the `docs` directory of the Repast Simphony project, or browsed online at the following links:

 * [http://cscs-repast-demos.googlecode.com/svn/richard/StupidModel/trunk/docs/javadoc_src/index.html Javadoc of the core model]
 * [http://cscs-repast-demos.googlecode.com/svn/richard/StupidModel/trunk/docs/javadoc_test/index.html Javadoc of the tests] written to verify the behaviour of the model
 * [http://cscs-repast-demos.googlecode.com/svn/richard/StupidModel/trunk/docs/cobertura/index.html Cobertura code coverage report] generated for the model to verify the test coverage

= Model List =
Each section of the following tutorial first describes the !StupidModel, a set of 16 simple template models designed as examples for learning how to use agent-based modeling platforms, then contains detailed notes on the implementation in Repast Simphony. Version 1 is the basic !StupidModel, which is extremely simple. As the first exercise in a class for nonprogrammers, Version 1 can be implemented in 2-3 hours. The subsequent versions incrementally add features that are commonly used in real models. These features include model elements such as interaction among individuals and their environment, stopping rules, alternative orders in which individuals execute their actions, mortality and reproduction, file input for habitat variables, and multiple kinds of agents. Some versions simply add software tools for observing the model: probes, graphs, and file output.

The documentation for each version states its purpose-what tool or technique is illustrated by the version, describes its formulation, and provides notes on how the changes were implemented in the example software.

The complete !StupidModel list:

 # [#Basic_StupidModel Basic StupidModel]
 # [#Bug_Growth Bug Growth]
 # [#Habitat_Cells_and_Resource Habitat Cells and Resource]
 # [#Cell_and_Bug_Probes Cell and Bug Probes]
 # [#Parameters_and_Parameter_Displays Parameters and Parameter Displays]
 # [#Histogram_Output Histogram Output]
 # [#Stopping_the_Model Stopping the Model]
 # [#File_Output File Output]
 # [#Randomized_Agent_Actions Randomized Agent Actions]
 # [#Sorted_Agent_Actions Sorted Agent Actions]
 # [#Optimal_Movement Optimal Movement]
 # [#Bug_Mortality_and_Reproduction Bug Mortality and Reproduction]
 # [#Population_Abundance_Graph Population Abundance Graph]
 # [#Random_Normal_Initial_Size Random Normal Initial Size]
 # [#Habitat_Data_from_File_Input Habitat Data from File Input]
 # [#Predators Predators]

== Basic !StupidModel ==

=== Purpose ===
This is the basic !StupidModel, an extremely simple individual-based model used as a starting point for learning Repast (or other IBM platforms).

=== Formulation ===
 * The space is a two-dimensional grid of dimensions `100 x 100`. The space is toroidal, meaning that if bugs move off one edge of the grid they appear on the opposite edge.
 * `100` bug agents are created. They have one behavior: moving to a randomly chosen grid location within `+/- 4` cells of their current location, in both the `X` and `Y` directions. If there already is a bug at the location (including the moving bug itself - bugs are not allowed to stay at their current location unless none of the neighborhood cells are vacant), then another new location is chosen. This action is executed once per time step.
 * The bugs are displayed on the space. Bugs are drawn as red circles. The display is updated at the end of each time step.
 * Instead of specifying which random number generation algorithm to use, the default generator for each platform is used.

=== Implementation Notes ===
First, start up Repast Simphony. If it is the first time the modelling environment is started, it asks for a default workspace. The _workspace_ is a directory used to store the models created, along with several settings. Please also make sure to switch to the _Java perspective_ by clicking the _Java_ button on the upper right corner.

https://cscs-repast-demos.googlecode.com/svn/wiki/StupidModel/switching_to_java_perspective.png

The outlook should change a bit: an Eclipse perspective determines the visible actions, buttons and views within the development environment. However, they all may be customized, and even new ones may be created afterwards.

https://cscs-repast-demos.googlecode.com/svn/wiki/StupidModel/java_perspective.png

The next step is to create our very fist Repast Simphony project! This may be done several ways, e.g.:

 * Click on the _File --> New --> Other..._ in the menu bar
 * Right-click on the _Project Explorer_ and select _New --> Other_ from the popup menu
 * Or, simply press the _Ctrl + N_ hotkey

A wizard dialogue shows up to create a new element on the workspace. 

https://cscs-repast-demos.googlecode.com/svn/wiki/StupidModel/create_new_simphony_project.png

Click on the _Next >_ button. A new wizard page is shown where the name of the project may be specified. Type `stupidmodel` into the _Project name_ text field, and press _Finish_.

https://cscs-repast-demos.googlecode.com/svn/wiki/StupidModel/new_sipmohy_project.png

  <b>Remark</b> You may also proceed to the next wizard page instead of pressing the finish button. Since a Repast Simphony project is generally a Java project, you may set some Java-specific settings on this page (e.g., the concrete build path with additional libraries, their ordering in the `CLASSPATH` variable, source and build paths, etc.). These settings are important principally when using Eclipse for Java development or for advanced users creating simulations with several 3rd party libraries. For the current model, the default settings are perfect for us.

After pressing the _Finish_ button, the freshly created project of the model should be shown in the _Package Explorer_ view.

https://cscs-repast-demos.googlecode.com/svn/wiki/StupidModel/new_project_created.png

As we stated in the [#Prerequisites preface], Simphony offers several ways to define a model. By default, it offers some skeleton files to start with for Groovy or Flowchart development. These files are `ModelInitializer.groovy` and `ModelInitializer.agent`, which may be deleted, since in the current tutorial we create a model using the standard Repast Simphony Java API. They may be deleted either by right-clicking on the resources and selecting _Delete_ from the popup menu as shown below, or by simply pressing the _Del_ button on the keyboard. 

https://cscs-repast-demos.googlecode.com/svn/wiki/StupidModel/delete_unnecessary_resources.png

==== Creating a Bug Agent ====

Our first task is to create a simple `Bug` agent. When using the standard Repast Simphony Java API, agents have not got to be additionally annotated: they are simple Java classes. So, the first step is to create a simple Java class file by pressing _Ctrl + N_ and selecting `Class` from the possibilities. On the next screen, assign `stupidmodel.agents` as the package of the new class, and `Bug` as its name. Press _Finish_.

https://cscs-repast-demos.googlecode.com/svn/wiki/StupidModel/create_new_bug_agent_class.png

A simple, empty Java class definition is created:

{{{
package stupidmodel.agents;

public class Bug {

}
}}}

  <b>Remark</b> Java classes are shown in a special editor that has very nice features. Since we are going to refer to specific line numbers in the following sections, it is recommended to turn on the line numbering feature. Right-click on the left side of the editor and select _Show line numbers_ from the popup menu.

https://cscs-repast-demos.googlecode.com/svn/wiki/StupidModel/enabling_line_numbers.png

We will also need a dedicated class to store model-specific constant values. It is usually a good and common practice to put these constants into one place (so when they had to be changed it may be done by modifying a simple value). The basic model has a few such values, namely:

 # The size of the two-dimensional grid (`100`)
 # The number of `Bug` agents to create at initialization (`100`) 
 # Tha vision range of `Bug` agents (`4`)

Create a new class named `Constants` in the package `stupidmodel.common`, and put these constant definitions into it as follows:

{{{
package stupidmodel.common;

public final class Constants {
        public static final int GRID_SIZE = 100;
        public static final int BUG_COUNT = 100;
        public static final int BUG_VISION_RANGE = 4;
}
}}}

Now, back to the `Bug` class. In the first demo version, the `Bug` agents will be located on a simple `Grid`. In Repast Simphony, the superclass of all type of grids is the `repast.simphony.space.grid.Grid` interface. In their constructors, we assing the associated `Grid` instance with the agents:

{{{
import repast.simphony.space.grid.Grid;

public class Bug {
        private final Grid<Object> grid;

        public Bug(final Grid<Object> grid) {
                this.grid = grid;
        }
}
}}}

The grid is assigned the Object generic type parameter, because in further models some other type of agents may be placed on it (i.e., `HabitatCell` and `Predator` instances, but more of them later on). 

For debugging we also add a default `toString()` implementation for the `Bug` agents. This comes handy when printing out an agent to the console or when debugging the simulation. The most important information about our agent is its current position at the grid, so we query it from the grid by the `getLocation()` function:

{{{
@Override
public String toString() {
	return String.format("Bug @ location ", grid.getLocation(this));
}
}}}

==== Creating a Utility Class ====

We would like to create simple agent behaviour, so creating a separate class for common utility functions sounds reasonable. Create a new class named `SMUtils` in the package `stupidmodel.common`, and add the following static utility method definitions:

{{{
package stupidmodel.common;

import java.util.ArrayList;
import java.util.List;

import repast.simphony.query.space.grid.GridCell;
import repast.simphony.random.RandomHelper;
import repast.simphony.space.grid.GridPoint;

public final strictfp class SMUtils {
        public static <T> T randomElementOf(final List<T> list) {
                return list.get(RandomHelper.nextIntFromTo(0, list.size() - 1));
        }

        public static <T> List<GridCell<T>> getFreeGridCells(
                        final List<GridCell<T>> neighborhood) {
                final ArrayList<GridCell<T>> ret = new ArrayList<GridCell<T>>();

                for (final GridCell<T> act : neighborhood) {
                        if (0 == act.size()) {
                                ret.add(act);
                        }
                }

                return ret;
        }
}
}}}

The first function, `randomElementOf()` is really simple: by utilizing the `repast.simphony.random.RandomHelper` class (which is the class in the Repast Simphony Java API that offers several utility functions to handle pseudorandom number generators) it returns one of the elements of the specified list randomly (based on a uniform distribution).

The other one, `getFreeGridCells()` may look a bit complicated for the first sight, but it is really simple on a second look. All of the created `Grid` objects contain `GridCell` instances on them. As the model defines, we would like to know if whether such a cell is empty or not: comparing the `size()` of the objects located on a `GridCell` to zero answers that question. The method, however, is a bit generalized, and accepts any list of `GridCell` objects.

==== Specifying an Agent Action ====

The last thing we need to add to our first `Bug` implementation is its `step()` action.

In Repast Simphony, one of the most convenient ways to define an agent action is to use the `@ScheduleMethod` annotation, which accepts several parameters, e.g., the first time step when the action should be activated, and the interval how often it should be executed (if it is a cyclic event). To define such an action, add the following method definition to the `Bug` class:

{{{
@ScheduledMethod(start = 1, interval = 1)
public void step() {
	...
}
}}}

  <b>Remark</b> From now on, for the sake of simplicity, we omit the fully qualified class names and `import` statements. Eclipse automatically inserts these, and in case of uncertainity the `Ctrl + Space` (_auto-complete feature_) combination can solve the situation. In case a whole code segment is inserted into the Java editor, using the `Ctrl + Shift + O` (_organize imports_) key combination solves all of the importing and namespace errors (in case of duplicate identifiers it asks for assistance).
  Using the hotkeys may really boost up the development speed. Press `Ctrl+Shift+L` to get a full list of usable hotkey combinations in the current context (e.g., in the Java editor), or see the full list of available ones through _Window -> Preferences -> General -> Keys_ settings page.

We defined an action that is executed for all `Bug` instance from the beginning (`start = 1`) of the simulation in each time step (`interval = 1`). Now, as the model defines, the first thing a `Bug` should do is to find its location, and query its neighbourhood.

Fortunately, there is a method we can use to find the neighborhood of an agent offered by the standard Repast Java API. We have to create an instance of class `GridCellNgh` and call its `getNeighborhood()` function.

 * To create a `GridCellNgh` instance, we have to specify the grid, the center location of the neighborhood and the extent (width, height) of the required neighborhood relation.
 * Calling the `getNeighborhood()` function is then quite straightforward: it requires only a logical parameter which determines to whether include the center location in the returned list or not. 

The result is a list of `GridCell` instances that make up the neighborhood.

{{{
final List<GridCell<Bug>> bugNeighborhood = new GridCellNgh<Bug>(grid,
	location, Bug.class, Constants.BUG_VISION_RANGE,
	Constants.BUG_VISION_RANGE).getNeighborhood(false);
}}}

We have a utility function that returns the filtered list of empty cells, and it is easy to use:

{{{
final List<GridCell<Bug>> freeCells = SMUtils
		.getFreeGridCells(bugNeighborhood);
}}}

As the model specifies the agent should not move if there is no available free cell in its neighborhood. In this case, we simply stop the execution of the action by calling a `return` statement.

{{{
if (freeCells.isEmpty()) {
	return;
}
}}}

The model specifies to choose a random element from the list. It may be done this way:

{{{
SimUtilities.shuffle(freeCells, RandomHelper.getUniform());
}}}

However, it is more convenient to choose a random element directly from the list of free cells as follows, so it is not a vital element of the activity:

{{{
final GridCell<Bug> chosenFreeCell = SMUtils.randomElementOf(freeCells);
}}}

After evaluating a new empty place for the agent, we can move it by calling the `moveTo()` method of the used `Grid` instance in order to relocate the agent. The functino has three parameters: the agent to move on the grid, and its new `x` and `y` locations (there may be arbitrary number of coordinates if requried, but in this example model we use a two-dimensional discrete space).

{{{
final GridPoint newGridPoint = chosenFreeCell.getPoint();
grid.moveTo(this, newGridPoint.getX(), newGridPoint.getY());
}}}

The whole body of the created action method is shown in the following code listing:

{{{
@ScheduledMethod(start = 1, interval = 1)
public void step() {
	final List<GridCell<Bug>> bugNeighborhood = new GridCellNgh<Bug>(grid,
		location, Bug.class, Constants.BUG_VISION_RANGE,
		Constants.BUG_VISION_RANGE).getNeighborhood(false);

	final List<GridCell<Bug>> freeCells = SMUtils
			.getFreeGridCells(bugNeighborhood);

	if (freeCells.isEmpty()) {
		return;
	}

	SimUtilities.shuffle(freeCells, RandomHelper.getUniform());

	final GridCell<HabitatCell> chosenFreeCell = habitatCells.get(0);

	final GridPoint newGridPoint = chosenFreeCell.getPoint();
	grid.moveTo(this, newGridPoint.getX(), newGridPoint.getY());
}
}}}

==== Creating the Simulation Context ====
One last piece is needed to complete the whole picture: a custom context builder implementation which is responsible to perform the initialization. This is done by creating a class that implements the `ContextBuilder<T>` interface, where `T` refers for the types added to the used context. Since we have different type of agents (i.e., `Bug`, `HabitatCell` and `Predator` agents), as mentioned previously we use `Object` as `T` (cf. the definition of `Bug` agents containing `Grid<Object>` members).

It is pretty simple to create a custom `ContextBuilder` implementation, because it declares only one function called `buildContext()`. The role of this function is to build and return a context. A default context instance is passed to the function that may be used when no special initialization is required, however, the returned context does not necessarily have to be the passed in context. 

Create a new class called `StupidModelContextBuilder` through the new class file wizard, and add `ContextBuilder` as its interface. The IDE will show up a new empty file with an empty implementation for the `build()` method:

https://cscs-repast-demos.googlecode.com/svn/wiki/StupidModel/create_stupidmodel_context_builder_class.png

The file shows some compilation errors, we have to modify it a bit in order to solve the errors and the warnings by assigning the class type parameter to `Object` as follows:

{{{
package stupidmodel;

import repast.simphony.context.Context;
import repast.simphony.dataLoader.ContextBuilder;

public class StupidModelContextBuilder implements ContextBuilder<Object> {
	@Override
	public Context<Object> build(Context<Object> context) {
		// TODO Auto-generated method stub
		return null;
	}
}
}}}

Building a context consists of filling it with agents, adding projects and so forth. In the few code blocks, we create and initialize a space and a grid, assign them and to the context unique IDs, and populate the context and the grid with Bug `agents`.

To implement the `build()` method as described, first define a few other constants, the IDs for the used projections:

{{{
public final class Constants {
	public static final String CONTEXT_ID = "StupidModel";
	public static final String SPACE_ID = "space";
	public static final String GRID_ID = "grid";

	// Other definitions omitted
	...
}
}}}

These are simple strings, the only rule for these identificators is to be different.

After we have these definitions, first we assign the context ID by the `setId()` function:

{{{
@Override
public Context<Object> build(final Context<Object> context) {
	context.setId(Constants.CONTEXT_ID);
}	
}}}

As we written above contexts can also have `Projections` associated with them. A `Projection` takes the agents in a `Context` and imposes some sort of structure on them. We will use a `ContinuousSpace` and a `Grid`: both of them are projections, and they take agents and locate them in a continuous space and a matrix-like grid, respectively. In the `build()` method we are thus going to create these `Projection` instances and assign them to the `Context` by the following way:

{{{
final ContinuousSpace<Object> space = ContinuousSpaceFactoryFinder
		.createContinuousSpaceFactory(null) // No hints
		.createContinuousSpace(
				Constants.SPACE_ID,
				context,
				new RandomCartesianAdder<Object>(),
				new repast.simphony.space.continuous.WrapAroundBorders(),
				Constants.GRID_SIZE, Constants.GRID_SIZE);

final Grid<Object> grid = GridFactoryFinder
		.createGridFactory(null)
		.createGrid(
				Constants.GRID_ID,
				context,
				new GridBuilderParameters<Object>(
						new repast.simphony.space.grid.WrapAroundBorders(),
						// This is a simple implementation of an adder
						// that doesn't perform any action
						new SimpleGridAdder<Object>(),
						// Each cell in the grid is single occupancy
						false,
						// Size of the grid (defined constants)
						Constants.GRID_SIZE, Constants.GRID_SIZE));

}}}


==== Configure Projections ====
This is the only part where a minor _"magic"_ is required. Open up the file `stupidmodel.rs/context.xml`. Repast Simphony includes a nice XML file editor, where the elements may be added through a graphical interface. After clicking on the _Source_ tab, the default content for the file should look something like this:

{{{
<context id="stupidmodel"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:noNamespaceSchemaLocation="http://repast.org/scenario/context">
</context>
}}}

In order to let the observer (the Repast S GUI and its several wizards) know about the projections we added to our model, the following modifications must be done:

{{{
<context id="stupidmodel"
		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		xsi:noNamespaceSchemaLocation="http://repast.org/scenario/context">
	<projection id="space" type="continuous space" />
	<projection id="grid" type="grid" /> 
</context>
}}}

Start the model.


=== Further Fun ===

 * When the new Repast Simphony project is instantiated, it created a several important directories. It represents a _suggested_ project layout, feel free to modify the layout if preferred, however, using conventions help other modelers understand your simulation, and make it running easier if the required resources may be found in the same places. Take some time to check the directory structure, and find a proper place to create a simple documentation for your model containing your name as the author and a link to the StupidModel documentation.
 * It is always good to know the API than to reinvent the wheel. Spend some time by checking out the utility methods offered by the Repast Simphony Java API, it can really save some time since they offer solutions and covers most of the common tasks. 
 * There are alternative ways to access any grid or space elements (in particular, any defined _projection_) through the context. In this version of the model, we directly passed a reference to the created agents. Can you figure out how to access the same grid instance with the defined `GRID_ID` through the context in which the agent is? *Hint:* An agent's context may be accessed anytime with a call to `ContextUtils.getContext(this)`.
 * Try the simulation out with different different vision ranges for the agents. Run the model with different number of agents to check they are moving correctly.
 * It is quite easy to set different visualization settings, spend a little time with playing them:
   * Try setting an icon for the bugs. It is pretty easy and makes the model look nicer.
   * Set a custom background color for the simulation!
 * Try to modify the current implementation to allow multiple agents stay on the same territory!.

=== Complete Model ===

 * The [https://cscs-repast-demos.googlecode.com/svn/richard/StupidModel/tags/2011_05_26_model_01/ complete source code] of the first model is accessible from the proper SVN tag directly.

== Bug Growth ==
=== Purpose ===
Illustrate adding instance variables and methods to the agents.
=== Formulation ===
 * Add a second bug action, `grow`. Each time step, a bug grows by a fixed amount, `1.0`. So bugs need an instance variable for their size, which is initialized to `1.0`. This action is scheduled after the `move` action.
 * The bugs' color on the display is shaded to reflect their size. Bug colors shade from white when size is zero to red when size is `10` or greater.

=== Implementation Notes ===

=== Further Fun ===
 * Try to schedule the `grow()` and `move()` actions with the same priority, run the model and check in which order are the actions executed.
 * Try to create different rainbow color maps for the agents.
 * Agents' `size` property is changed by the same fixed number. Try to introduce minor heterogeneity through randomizing the `grow()` action: make the `size` property increased by a random value between the interval `[0.5, 1.5]`.

=== Complete Model ===

 * The [https://cscs-repast-demos.googlecode.com/svn/richard/StupidModel/tags/2011_05_28_model_02 complete source code] of the first model is accessible from the proper SVN tag directly.

== Habitat Cells and Resource ==
=== Purpose ===
Show how to create cell objects that represent habitat and spatial resources. Illustrate how agents and habitat cells interact.
=== Formulation ===
 * A new class, `HabitatCell`, is added. Habitat cell objects have instance variables for their `foodAvailability` and `maximumFoodProductionRate`. Cells also have a variable for the bug at their location.
 * The grid space object now holds habitat cells, not bugs.
 * Food availability is initialized to `0.0`, and maximum food production rate is initialized to `0.01`.
 * Each time step, food availability is increased by food production. Food production is a random floating point number between zero and the maximum food production.
 * Food production is scheduled before agent actions.
 * Bug growth is modified so growth equals food consumption. Food consumption is equal to the minimum of (a) the bug's maximum consumption rate (set to 1.0) and (b) the bug's cell's food availability.
 * The food consumed by each bug is subtracted from the food availability of its cell.

=== Implementation Notes ===

=== Further Fun ===
 * Try increasing the `maximumFoodProductionRate` to a relatively high value (e.g. set it to `10.0`). Make some experimental runs, and check what you see and how it fits your expectations.
 * Try using some other color values to display food availability for the grid.

=== Complete Model ===

 * The [https://to.do complete source code] of the first model is accessible from the proper SVN tag directly.


== Cell and Bug Probes ==
=== Purpose ===
Show how to make model objects probeable from the display.
=== Formulation ===
Make the bugs, and the cells, so they can be probed via mouse clicks on the display.

== Parameters and Parameter Displays ==
=== Purpose ===
Show howto define variables as parameters, and how to put parameters in the parameter settings window that appears at startup.
=== Formulation ===
Make these variables into parameters that can be accessed through the settings window:
 * Initial number of bugs (a model parameter)
 * The maximum daily food consumption (a bug parameter), and
 * The maximum food production (a cell parameter).

== Histogram Output ==
=== Purpose ===
Illustrate how to add graphs to the display. Provide the ability to see the size distribution of the agents.
=== Formulation ===
Add a histogram display showing the number of agents in each size class. (It works reasonably well to use 10 bins, set minimum to zero, and set maximum to 10.)

== Stopping the Model ==
=== Purpose ===
Show how to cause a model to stop itself upon a certain condition. Show how to "clean up" when a model stops.

=== Formulation ===
 * The model stops when the largest bug reaches a size of 100.
 * Close the graphic windows (and do any other cleanup steps) when the program stops.

== File Output ==
=== Purpose ===
Show how to write results to an output file. Illustrate how to iterate over a list.
=== Formulation ===
Each time step, write the minimum, mean, and maximum bug size on one line of an output file.

== Randomized Agent Actions ==
=== Purpose ===
Show how to randomize the order in which agents execute an action.
=== Formulation ===
The bugs' move action is altered so that the order in which bugs execute the action is shuffled each time step.

== Sorted Agent Actions ==
=== Purpose ===
Show how to sort a list of agents, and cause an agent action to be executed in size order.
=== Formulation ===
 * The list of bugs is sorted by descending size order at the start of each time step.
 * The bugs' move action is un-randomized so it is executed in descending size order.

== Optimal Movement ==
=== Purpose ===
Show how agents can identify and rank neighbor cells. Illustrate how to iterate over a list.
=== Formulation ===
 * In its move method, a bug identifies a list of all cells that are within a distance of 4 grids but do not have another bug in them. (The bug’s current cell is included on this list.)
 * The bug iterates over the list and identifies the cell with highest food availability. The bug then moves to that cell.

== Bug Mortality and Reproduction ==
=== Purpose ===
Show how to "kill" and drop objects from a model, and how to create new objects during a run.
=== Formulation ===
 * When a bug's size reaches 10, it reproduces by splitting into 5 new bugs. Each new bug has an initial size of 0.0, and the old bug disappears.
 * New bugs are placed at the first empty location randomly selected within +/- 3 cells of their parent's last location. If no location is identified within 5 random draws, then the new bug dies.
 * A new bug parameter `survivalProbability` is initialized to 0.95. Each time step, each bug draws a uniform random number, and if it is greater than `survivalProbability`, the bug dies and is dropped.
 * This mortality action is scheduled after the bug moves and grows.
 * The model stopping rule is changed: the model stops after 1000 time steps have been executed or when the number of bugs reaches zero.

== Population Abundance Graph ==
=== Purpose ===
Show how to add a simple time series graph to a model. This graph is important for understanding results now that reproduction and mortality change the abundance of bugs.
=== Formulation ===
No change is made to the model formulation. A graph is added to display the number of bugs alive at each time step.

== Random Normal Initial Size ==
=== Purpose ===
Illustrate use of random number distributions. A common use of them is to induce variability among initial individuals.
=== Formulation ===
 * Two new model parameters are added, and put on the parameter settings window: `initialBugSizeMean` and `initialBugSizeSD`. Values of these parameters are `0.1` and `0.03`.
 * Instead of initializing bug sizes to `1.0` (See [#Bug_Growth here]), sizes are drawn from a normal distribution defined by `initialBugSizeMean` and `initialBugSizeSD`. The initial size of bugs produced via reproduction is `0.0`.
 * Negative values are very likely to be drawn from normal distributions such as the one used here. To avoid them, a check is introduced to limit initial bug size to a minimum of zero.

=== Implementation Notes ===

=== Further Fun ===
 * The basic parameter settings of the _mean_ and _standard deviation_ do not really have a visible influence on the histogram of size distribution. Modify the parameters and check the histogram if you see what you expect from the modified parameter values!
 * Size of the reproduced bug agents after initialization is still homogeneous. Can you include new parameters for the spawned bug agent size to be drawn from a different normal distribution (e.g., `reproducedBugSizeMean` and `reproducedBugSizeSD` with values `1.5` and `0.7`, respectively)?

=== Complete Model ===

 * The [https://cscs-repast-demos.googlecode.com/svn/richard/StupidModel/tags/2011_06_15_model_14/ complete source code] of the first model is accessible from the proper SVN tag directly.


== Habitat Data from File Input ==
=== Purpose ===
Show how to read spatial data in from a file.
=== Formulation ===
 * Instead of assuming the space size and assuming cell food production is random (See [#Habitat_Cells_and_Resource  here]), food production rates are read in from a file. The file also determines the space size.
 * The file contains one line per cell, with (a) X coordinate, (b) Y coordinate, and (c) food production rate.
 * Food production in a cell is now equal to the production rate read in from the file, and is no longer random.
 * Now, because we are representing real habitat with real data, it no longer makes sense for the space to be toroidal. So the space objects and movement-related methods must be modified so bugs cannot move off the edge of their space.
 * The input file is `Stupid_Cell.Data`. It has X, Y, and food production data for a grid space. X ranges from 0 to 250; Y ranges from 0 to 112. The file starts with three lines of header information that is ignored by the model.
 * The cells are now displayed and colored to indicate their current food availability. Cell colors scale from black when cell food availability is zero to green when food availability is 0.5 or higher.
 * A change to the bug move method is required to avoid a very strong artifact now that cell food production is no longer random. Near the start of a simulation, many cells will have exactly the same food availability, so a bug simply would move to the first cell on its list of neighbor cells. This is always the top-left cell among the neighbors, so bugs move constantly up and left if all the cells available to them have the same food availability. This artifact is removed by randomly shuffling the list of available cells before the bug loops through it to identify the best.

== Predators ==
=== Purpose ===
Show how to create multiple classes of agents that interact.
=== Formulation ===
 * 200 predator objects are intialized and randomly distributed as the bugs are. A cell can contain a predator as well as a bug. Predators are created after bugs are.
 * Predators have one method: hunt. First, a predator looks through a shuffled list of its immediately neighboring cells (including its own cell). As soon as the predator finds a bug in one of these cells it "kills" the bug and moves into the cell. (However, if the cell already contains a predator, the hunting predator simply quits and remains at its current location.) If these cells contain no bugs, the predator moves randomly to one of them.
 * Predator hunting is scheduled after all the bug actions.

= Conclusion =

= References =
 # Steven F. Railsback, Steven L. Lytinen and Stephen K. Jackson: _"!StupidModel and Extensions: A template and teaching tool for agent-based modeling platforms"_, (December 20, 2005) http://condor.depaul.edu/~slytinen/abm/StupidModelFormulation.pdf
 # Isaac, Alan G.: _"The ABM Template Models: A Reformulation with Reference Implementations"_, Journal of Artificial Societies and Social Simulation 14 (2) 5, (2011) http://jasss.soc.surrey.ac.uk/14/2/5.html
 # Richard O. Legendi, Attila Szabo: _[http://distributedabm.elte.hu/letoltesek/publikaciok/2010_01_ICAI_Advantages_of_Fables_paper.pdf "Advantages of a Multi-Paradigm Programming Language in Agent-Based Model Definition"]_, ICAI 2010 - 8th International Conference on Applied Informatics (Eger, Hungary, January 27 - 30, 2010)

